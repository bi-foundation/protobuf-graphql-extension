// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: flavortown.proto

package flavortown

import (
	bytes "bytes"
	fmt "fmt"
	dessert "github.com/bi-foundation/protobuf-graphql-extension/examples/dessert"
	_ "github.com/bi-foundation/protobuf-graphql-extension/graphqlproto"
	types "github.com/bi-foundation/protobuf-graphql-extension/graphqlproto/types"
	github_com_opsee_protobuf_plugin_graphql_scalars "github.com/bi-foundation/protobuf-graphql-extension/plugin/graphql/scalars"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_graphql_go_graphql "github.com/graphql-go/graphql"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// quality of comment
type Quality int32

const (
	Quality_EXPENSIVE Quality = 0
	Quality_FAIR      Quality = 1
	Quality_CHEAP     Quality = 2
)

var Quality_name = map[int32]string{
	0: "EXPENSIVE",
	1: "FAIR",
	2: "CHEAP",
}

var Quality_value = map[string]int32{
	"EXPENSIVE": 0,
	"FAIR":      1,
	"CHEAP":     2,
}

func (x Quality) String() string {
	return proto.EnumName(Quality_name, int32(x))
}

func (Quality) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d9e987dd7972d0e8, []int{0}
}

// The menu at Guy’s American Kitchen & Bar reflects his signature style of authentic and surprising flavors
type Menu struct {
	// These dishes are crafted with the heart and soul of hometown favorites and infused with Guy’s big, daring flavors
	Items                []*LineItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Menu) Reset()         { *m = Menu{} }
func (m *Menu) String() string { return proto.CompactTextString(m) }
func (*Menu) ProtoMessage()    {}
func (*Menu) Descriptor() ([]byte, []int) {
	return fileDescriptor_d9e987dd7972d0e8, []int{0}
}
func (m *Menu) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Menu) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Menu.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Menu) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Menu.Merge(m, src)
}
func (m *Menu) XXX_Size() int {
	return m.Size()
}
func (m *Menu) XXX_DiscardUnknown() {
	xxx_messageInfo_Menu.DiscardUnknown(m)
}

var xxx_messageInfo_Menu proto.InternalMessageInfo

func (m *Menu) GetItems() []*LineItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// A line item representing a dish and price
type LineItem struct {
	// The menu dish, can either be lunch or dessert
	//
	// Types that are valid to be assigned to Dish:
	//	*LineItem_Lunch
	//	*LineItem_TastyDessert
	Dish isLineItem_Dish `protobuf_oneof:"dish"`
	// The price of the dish in cents
	PriceCents uint32 `protobuf:"varint,2,opt,name=price_cents,json=priceCents,proto3" json:"price_cents,omitempty"`
	// A timestamp representing when the dish was added to the menu
	CreatedAt *types.Timestamp `protobuf:"bytes,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// A timestamp representing when the dish was updated
	UpdatedAt *types.Timestamp `protobuf:"bytes,4,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	// A list of nothing really
	Nothing *Nothing `protobuf:"bytes,5,opt,name=nothing,proto3" json:"nothing,omitempty"`
	// permission to eat?
	Sides *types.Permission `protobuf:"bytes,6,opt,name=sides,proto3" json:"sides,omitempty"`
	// quality of item
	QualityControl       Quality  `protobuf:"varint,7,opt,name=qualityControl,proto3,enum=flavortown.Quality" json:"qualityControl,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LineItem) Reset()         { *m = LineItem{} }
func (m *LineItem) String() string { return proto.CompactTextString(m) }
func (*LineItem) ProtoMessage()    {}
func (*LineItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_d9e987dd7972d0e8, []int{1}
}
func (m *LineItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LineItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LineItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LineItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LineItem.Merge(m, src)
}
func (m *LineItem) XXX_Size() int {
	return m.Size()
}
func (m *LineItem) XXX_DiscardUnknown() {
	xxx_messageInfo_LineItem.DiscardUnknown(m)
}

var xxx_messageInfo_LineItem proto.InternalMessageInfo

type isLineItem_Dish interface {
	isLineItem_Dish()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LineItem_Lunch struct {
	Lunch *Lunch `protobuf:"bytes,100,opt,name=lunch,proto3,oneof"`
}
type LineItem_TastyDessert struct {
	TastyDessert *dessert.Dessert `protobuf:"bytes,101,opt,name=tasty_dessert,json=tastyDessert,proto3,oneof"`
}

func (*LineItem_Lunch) isLineItem_Dish()        {}
func (*LineItem_TastyDessert) isLineItem_Dish() {}

func (m *LineItem) GetDish() isLineItem_Dish {
	if m != nil {
		return m.Dish
	}
	return nil
}

func (m *LineItem) GetLunch() *Lunch {
	if x, ok := m.GetDish().(*LineItem_Lunch); ok {
		return x.Lunch
	}
	return nil
}

func (m *LineItem) GetTastyDessert() *dessert.Dessert {
	if x, ok := m.GetDish().(*LineItem_TastyDessert); ok {
		return x.TastyDessert
	}
	return nil
}

func (m *LineItem) GetPriceCents() uint32 {
	if m != nil {
		return m.PriceCents
	}
	return 0
}

func (m *LineItem) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *LineItem) GetUpdatedAt() *types.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

func (m *LineItem) GetNothing() *Nothing {
	if m != nil {
		return m.Nothing
	}
	return nil
}

func (m *LineItem) GetSides() *types.Permission {
	if m != nil {
		return m.Sides
	}
	return nil
}

func (m *LineItem) GetQualityControl() Quality {
	if m != nil {
		return m.QualityControl
	}
	return Quality_EXPENSIVE
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LineItem) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LineItem_OneofMarshaler, _LineItem_OneofUnmarshaler, _LineItem_OneofSizer, []interface{}{
		(*LineItem_Lunch)(nil),
		(*LineItem_TastyDessert)(nil),
	}
}

func _LineItem_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LineItem)
	// dish
	switch x := m.Dish.(type) {
	case *LineItem_Lunch:
		_ = b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Lunch); err != nil {
			return err
		}
	case *LineItem_TastyDessert:
		_ = b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TastyDessert); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LineItem.Dish has unexpected type %T", x)
	}
	return nil
}

func _LineItem_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LineItem)
	switch tag {
	case 100: // dish.lunch
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Lunch)
		err := b.DecodeMessage(msg)
		m.Dish = &LineItem_Lunch{msg}
		return true, err
	case 101: // dish.tasty_dessert
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(dessert.Dessert)
		err := b.DecodeMessage(msg)
		m.Dish = &LineItem_TastyDessert{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LineItem_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LineItem)
	// dish
	switch x := m.Dish.(type) {
	case *LineItem_Lunch:
		s := proto.Size(x.Lunch)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LineItem_TastyDessert:
		s := proto.Size(x.TastyDessert)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A delicious lunch dish on the menu
type Lunch struct {
	// The name of the dish
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The description of the dish
	Description []byte `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// a wild map. lunch tags? i guess
	Tags                 map[string]string `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Lunch) Reset()         { *m = Lunch{} }
func (m *Lunch) String() string { return proto.CompactTextString(m) }
func (*Lunch) ProtoMessage()    {}
func (*Lunch) Descriptor() ([]byte, []int) {
	return fileDescriptor_d9e987dd7972d0e8, []int{2}
}
func (m *Lunch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Lunch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Lunch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Lunch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lunch.Merge(m, src)
}
func (m *Lunch) XXX_Size() int {
	return m.Size()
}
func (m *Lunch) XXX_DiscardUnknown() {
	xxx_messageInfo_Lunch.DiscardUnknown(m)
}

var xxx_messageInfo_Lunch proto.InternalMessageInfo

func (m *Lunch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Lunch) GetDescription() []byte {
	if m != nil {
		return m.Description
	}
	return nil
}

func (m *Lunch) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// confusion
type Nothing struct {
	// the void
	Void                 string   `protobuf:"bytes,1,opt,name=void,proto3" json:"void,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Nothing) Reset()         { *m = Nothing{} }
func (m *Nothing) String() string { return proto.CompactTextString(m) }
func (*Nothing) ProtoMessage()    {}
func (*Nothing) Descriptor() ([]byte, []int) {
	return fileDescriptor_d9e987dd7972d0e8, []int{3}
}
func (m *Nothing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Nothing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Nothing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Nothing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Nothing.Merge(m, src)
}
func (m *Nothing) XXX_Size() int {
	return m.Size()
}
func (m *Nothing) XXX_DiscardUnknown() {
	xxx_messageInfo_Nothing.DiscardUnknown(m)
}

var xxx_messageInfo_Nothing proto.InternalMessageInfo

func (m *Nothing) GetVoid() string {
	if m != nil {
		return m.Void
	}
	return ""
}

func init() {
	proto.RegisterEnum("flavortown.Quality", Quality_name, Quality_value)
	proto.RegisterType((*Menu)(nil), "flavortown.Menu")
	proto.RegisterType((*LineItem)(nil), "flavortown.LineItem")
	proto.RegisterType((*Lunch)(nil), "flavortown.Lunch")
	proto.RegisterMapType((map[string]string)(nil), "flavortown.Lunch.TagsEntry")
	proto.RegisterType((*Nothing)(nil), "flavortown.Nothing")
}

func init() { proto.RegisterFile("flavortown.proto", fileDescriptor_d9e987dd7972d0e8) }

var fileDescriptor_d9e987dd7972d0e8 = []byte{
	// 586 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0xc1, 0x6e, 0xd3, 0x4c,
	0x10, 0xc7, 0xbb, 0x4d, 0xdc, 0x34, 0x93, 0xb6, 0xca, 0xb7, 0x5f, 0x05, 0x56, 0x0b, 0xae, 0x95,
	0x53, 0xa8, 0x14, 0x1b, 0x15, 0x21, 0xaa, 0xc2, 0x25, 0x2d, 0x41, 0xad, 0x04, 0x55, 0x59, 0x2a,
	0xc4, 0xad, 0x72, 0xed, 0xad, 0xb3, 0xc2, 0xde, 0x35, 0xde, 0x75, 0x21, 0xaf, 0xc3, 0x05, 0x24,
	0x5e, 0x80, 0x23, 0x47, 0x8e, 0x3c, 0x02, 0xe4, 0x29, 0x38, 0x22, 0xef, 0xda, 0x6d, 0x0a, 0x02,
	0xc1, 0xc9, 0x33, 0xb3, 0xff, 0x9f, 0xff, 0xb3, 0x33, 0x0b, 0xdd, 0xb3, 0x24, 0x38, 0x17, 0xb9,
	0x12, 0xaf, 0xb9, 0x97, 0xe5, 0x42, 0x09, 0x0c, 0x97, 0x95, 0xb5, 0x07, 0x31, 0x53, 0xe3, 0xe2,
	0xd4, 0x0b, 0x45, 0xea, 0x8b, 0x4c, 0x52, 0xea, 0x6b, 0xcd, 0x69, 0x71, 0x66, 0x52, 0x9d, 0xf9,
	0x6a, 0x92, 0x51, 0xe9, 0x67, 0x34, 0x4f, 0x99, 0x94, 0x4c, 0x70, 0x69, 0xfe, 0xb4, 0xb6, 0xf3,
	0x0f, 0xb4, 0x62, 0x29, 0x95, 0x2a, 0x48, 0xb3, 0x8a, 0x1d, 0xcc, 0xb0, 0xb1, 0x88, 0xc5, 0x25,
	0x5a, 0x66, 0x86, 0x2c, 0xa3, 0x4a, 0x7e, 0xfb, 0xaf, 0xac, 0x74, 0x58, 0x11, 0xdb, 0xbf, 0x27,
	0xe8, 0x9b, 0x20, 0xcd, 0x12, 0x2a, 0xfd, 0x88, 0x4a, 0x49, 0x73, 0x55, 0x7f, 0x0d, 0xd9, 0xdb,
	0x82, 0xe6, 0x13, 0xca, 0x0b, 0xbc, 0x09, 0x16, 0x53, 0x34, 0x95, 0x36, 0x72, 0x1b, 0xfd, 0xce,
	0xd6, 0xaa, 0x37, 0x33, 0xca, 0xc7, 0x8c, 0xd3, 0x03, 0x45, 0x53, 0x62, 0x24, 0xbd, 0x0f, 0x0d,
	0x58, 0xac, 0x6b, 0xf8, 0x16, 0x58, 0x49, 0xc1, 0xc3, 0xb1, 0x1d, 0xb9, 0xa8, 0xdf, 0xd9, 0xfa,
	0xef, 0x0a, 0x58, 0x1e, 0xec, 0xcf, 0x11, 0xa3, 0xc0, 0xbb, 0xb0, 0xac, 0x02, 0xa9, 0x26, 0x27,
	0x55, 0x0b, 0x36, 0xd5, 0xc8, 0xfa, 0x2c, 0x52, 0x77, 0xf7, 0xd0, 0x7c, 0xf7, 0xe7, 0xc8, 0x92,
	0x66, 0xaa, 0x1c, 0x6f, 0x40, 0x27, 0xcb, 0x59, 0x48, 0x4f, 0x42, 0xca, 0x95, 0xb4, 0xe7, 0x5d,
	0xd4, 0x5f, 0x26, 0xa0, 0x4b, 0x7b, 0x65, 0x05, 0xdf, 0x05, 0x08, 0x73, 0x1a, 0x28, 0x1a, 0x9d,
	0x04, 0xca, 0x6e, 0x68, 0x87, 0x6b, 0x9e, 0x19, 0x96, 0xde, 0x8e, 0x77, 0x5c, 0x6f, 0x87, 0xb4,
	0x2b, 0xe5, 0x50, 0x95, 0x58, 0x91, 0x45, 0x35, 0xd6, 0xfc, 0x33, 0x56, 0x29, 0x87, 0x0a, 0x0f,
	0xa0, 0xc5, 0x85, 0x1a, 0x33, 0x1e, 0xdb, 0x96, 0x66, 0xfe, 0x9f, 0xbd, 0xcc, 0xa1, 0x39, 0x22,
	0xb5, 0x06, 0x0f, 0xc0, 0x92, 0x2c, 0xa2, 0xd2, 0x5e, 0xd0, 0xe2, 0xeb, 0x57, 0x0c, 0x8e, 0x2e,
	0xde, 0x1c, 0x31, 0x2a, 0x7c, 0x1f, 0x56, 0x5e, 0x15, 0x41, 0xc2, 0xd4, 0x64, 0x4f, 0x70, 0x95,
	0x8b, 0xc4, 0x6e, 0xb9, 0xa8, 0xbf, 0x72, 0xd5, 0xe4, 0xa9, 0x51, 0x90, 0x9f, 0xa4, 0xbb, 0x0b,
	0xd0, 0x8c, 0x98, 0x1c, 0xf7, 0xde, 0x21, 0xb0, 0xf4, 0x22, 0x30, 0x86, 0x26, 0x0f, 0x52, 0x6a,
	0x23, 0x17, 0xf5, 0xdb, 0x44, 0xc7, 0xd8, 0x85, 0x4e, 0x44, 0x65, 0x98, 0xb3, 0x4c, 0x31, 0xc1,
	0xf5, 0x3c, 0x97, 0xc8, 0x6c, 0x09, 0xfb, 0xd0, 0x54, 0x41, 0x2c, 0xed, 0x86, 0x7e, 0x18, 0xeb,
	0xbf, 0xec, 0xd7, 0x3b, 0x0e, 0x62, 0x39, 0xe2, 0x2a, 0x9f, 0x10, 0x2d, 0x5c, 0xbb, 0x07, 0xed,
	0x8b, 0x12, 0xee, 0x42, 0xe3, 0x25, 0x9d, 0x54, 0x96, 0x65, 0x88, 0x57, 0xc1, 0x3a, 0x0f, 0x92,
	0x82, 0x6a, 0xaf, 0x36, 0x31, 0xc9, 0xce, 0xfc, 0x36, 0xea, 0xdd, 0x84, 0x56, 0x35, 0xb1, 0xb2,
	0xd5, 0x73, 0xc1, 0xa2, 0xba, 0xd5, 0x32, 0xde, 0x1c, 0x40, 0xab, 0xba, 0x2b, 0x5e, 0x86, 0xf6,
	0xe8, 0xc5, 0xd1, 0xe8, 0xf0, 0xd9, 0xc1, 0xf3, 0x51, 0x77, 0x0e, 0x2f, 0x42, 0xf3, 0xd1, 0xf0,
	0x80, 0x74, 0x11, 0x6e, 0x83, 0xb5, 0xb7, 0x3f, 0x1a, 0x1e, 0x75, 0xe7, 0x77, 0x6f, 0x7c, 0xff,
	0xe6, 0xa0, 0xf7, 0x53, 0x07, 0x7d, 0x9c, 0x3a, 0xe8, 0xf3, 0xd4, 0x41, 0x5f, 0xa6, 0x0e, 0xfa,
	0x3a, 0x75, 0xd0, 0xa7, 0xb7, 0x1b, 0xe8, 0x74, 0x41, 0x3f, 0xff, 0x3b, 0x3f, 0x02, 0x00, 0x00,
	0xff, 0xff, 0x6b, 0x25, 0x28, 0x58, 0x33, 0x04, 0x00, 0x00,
}

func (this *Menu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Menu)
	if !ok {
		that2, ok := that.(Menu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *LineItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LineItem)
	if !ok {
		that2, ok := that.(LineItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Dish == nil {
		if this.Dish != nil {
			return false
		}
	} else if this.Dish == nil {
		return false
	} else if !this.Dish.Equal(that1.Dish) {
		return false
	}
	if this.PriceCents != that1.PriceCents {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	if !this.Nothing.Equal(that1.Nothing) {
		return false
	}
	if !this.Sides.Equal(that1.Sides) {
		return false
	}
	if this.QualityControl != that1.QualityControl {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *LineItem_Lunch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LineItem_Lunch)
	if !ok {
		that2, ok := that.(LineItem_Lunch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Lunch.Equal(that1.Lunch) {
		return false
	}
	return true
}
func (this *LineItem_TastyDessert) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LineItem_TastyDessert)
	if !ok {
		that2, ok := that.(LineItem_TastyDessert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TastyDessert.Equal(that1.TastyDessert) {
		return false
	}
	return true
}
func (this *Lunch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Lunch)
	if !ok {
		that2, ok := that.(Lunch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !bytes.Equal(this.Description, that1.Description) {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Nothing) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Nothing)
	if !ok {
		that2, ok := that.(Nothing)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Void != that1.Void {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}

var GraphQLQualityEnum *github_com_graphql_go_graphql.Enum

type MenuGetter interface {
	GetMenu() *Menu
}

var GraphQLMenuType *github_com_graphql_go_graphql.Object

type LineItemGetter interface {
	GetLineItem() *LineItem
}

var GraphQLLineItemType *github_com_graphql_go_graphql.Object
var GraphQLLineItemDishUnion *github_com_graphql_go_graphql.Union

type LunchGetter interface {
	GetLunch() *Lunch
}

var GraphQLLunchType *github_com_graphql_go_graphql.Object
var GraphQLLunch_TagsEntryType = github_com_opsee_protobuf_plugin_graphql_scalars.Map

type NothingGetter interface {
	GetNothing() *Nothing
}

var GraphQLNothingType *github_com_graphql_go_graphql.Object

func (g *LineItem_Lunch) GetLunch() *Lunch {
	return g.Lunch
}
func (g *LineItem_TastyDessert) GetDessert() *dessert.Dessert {
	return g.TastyDessert
}

func init() {
	GraphQLQualityEnum = github_com_graphql_go_graphql.NewEnum(github_com_graphql_go_graphql.EnumConfig{
		Name: "Quality",
		Values: github_com_graphql_go_graphql.EnumValueConfigMap{
			"EXPENSIVE": &github_com_graphql_go_graphql.EnumValueConfig{
				Value: 0,
			},
			"FAIR": &github_com_graphql_go_graphql.EnumValueConfig{
				Value: 1,
			},
			"CHEAP": &github_com_graphql_go_graphql.EnumValueConfig{
				Value: 2,
			},
		},
	})
	GraphQLMenuType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "Menu",
		Description: "The menu at Guy’s American Kitchen & Bar reflects his signature style of authentic and surprising flavors",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"items": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLLineItemType),
					Description: "These dishes are crafted with the heart and soul of hometown favorites and infused with Guy’s big, daring flavors",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Menu)
						if ok {
							return obj.Items, nil
						}
						inter, ok := p.Source.(MenuGetter)
						if ok {
							face := inter.GetMenu()
							if face == nil {
								return nil, nil
							}
							return face.Items, nil
						}
						return nil, fmt.Errorf("field items not resolved")
					},
				},
			}
		}),
	})
	GraphQLLineItemType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "LineItem",
		Description: "A line item representing a dish and price",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"price_cents": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "The price of the dish in cents",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LineItem)
						if ok {
							return obj.PriceCents, nil
						}
						inter, ok := p.Source.(LineItemGetter)
						if ok {
							face := inter.GetLineItem()
							if face == nil {
								return nil, nil
							}
							return face.PriceCents, nil
						}
						return nil, fmt.Errorf("field price_cents not resolved")
					},
				},
				"created_at": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "A timestamp representing when the dish was added to the menu",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LineItem)
						if ok {
							if obj.CreatedAt == nil {
								return nil, nil
							}
							return obj.GetCreatedAt(), nil
						}
						inter, ok := p.Source.(LineItemGetter)
						if ok {
							face := inter.GetLineItem()
							if face == nil {
								return nil, nil
							}
							if face.CreatedAt == nil {
								return nil, nil
							}
							return face.GetCreatedAt(), nil
						}
						return nil, fmt.Errorf("field created_at not resolved")
					},
				},
				"updated_at": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "A timestamp representing when the dish was updated",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LineItem)
						if ok {
							if obj.UpdatedAt == nil {
								return nil, nil
							}
							return obj.GetUpdatedAt(), nil
						}
						inter, ok := p.Source.(LineItemGetter)
						if ok {
							face := inter.GetLineItem()
							if face == nil {
								return nil, nil
							}
							if face.UpdatedAt == nil {
								return nil, nil
							}
							return face.GetUpdatedAt(), nil
						}
						return nil, fmt.Errorf("field updated_at not resolved")
					},
				},
				"nothing": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLNothingType,
					Description: "A list of nothing really",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LineItem)
						if ok {
							if obj.Nothing == nil {
								return nil, nil
							}
							return obj.GetNothing(), nil
						}
						inter, ok := p.Source.(LineItemGetter)
						if ok {
							face := inter.GetLineItem()
							if face == nil {
								return nil, nil
							}
							if face.Nothing == nil {
								return nil, nil
							}
							return face.GetNothing(), nil
						}
						return nil, fmt.Errorf("field nothing not resolved")
					},
				},
				"sides": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Permission,
					Description: "permission to eat?",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LineItem)
						if ok {
							if obj.Sides == nil {
								return nil, nil
							}
							return obj.GetSides(), nil
						}
						inter, ok := p.Source.(LineItemGetter)
						if ok {
							face := inter.GetLineItem()
							if face == nil {
								return nil, nil
							}
							if face.Sides == nil {
								return nil, nil
							}
							return face.GetSides(), nil
						}
						return nil, fmt.Errorf("field sides not resolved")
					},
				},
				"qualityControl": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLQualityEnum,
					Description: "quality of item",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LineItem)
						if ok {
							return int(Quality_value[obj.QualityControl.String()]), nil
						}
						inter, ok := p.Source.(LineItemGetter)
						if ok {
							face := inter.GetLineItem()
							if face == nil {
								return nil, nil
							}
							return int(Quality_value[face.QualityControl.String()]), nil
						}
						return nil, fmt.Errorf("field qualityControl not resolved")
					},
				},
				"dish": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLLineItemDishUnion,
					Description: "The menu dish, can either be lunch or dessert",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LineItem)
						if !ok {
							return nil, fmt.Errorf("field dish not resolved")
						}
						return obj.GetDish(), nil
					},
				},
			}
		}),
	})
	GraphQLLunchType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "Lunch",
		Description: "A delicious lunch dish on the menu",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "The name of the dish",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Lunch)
						if ok {
							return obj.Name, nil
						}
						inter, ok := p.Source.(LunchGetter)
						if ok {
							face := inter.GetLunch()
							if face == nil {
								return nil, nil
							}
							return face.Name, nil
						}
						return nil, fmt.Errorf("field name not resolved")
					},
				},
				"description": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.ByteString,
					Description: "The description of the dish",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Lunch)
						if ok {
							return obj.Description, nil
						}
						inter, ok := p.Source.(LunchGetter)
						if ok {
							face := inter.GetLunch()
							if face == nil {
								return nil, nil
							}
							return face.Description, nil
						}
						return nil, fmt.Errorf("field description not resolved")
					},
				},
				"tags": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLLunch_TagsEntryType,
					Description: "a wild map. lunch tags? i guess",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Lunch)
						if ok {
							return obj.Tags, nil
						}
						inter, ok := p.Source.(LunchGetter)
						if ok {
							face := inter.GetLunch()
							if face == nil {
								return nil, nil
							}
							return face.Tags, nil
						}
						return nil, fmt.Errorf("field tags not resolved")
					},
				},
			}
		}),
	})
	GraphQLNothingType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "Nothing",
		Description: "confusion",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"void": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "the void",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Nothing)
						if ok {
							return obj.Void, nil
						}
						inter, ok := p.Source.(NothingGetter)
						if ok {
							face := inter.GetNothing()
							if face == nil {
								return nil, nil
							}
							return face.Void, nil
						}
						return nil, fmt.Errorf("field void not resolved")
					},
				},
			}
		}),
	})
	GraphQLLineItemDishUnion = github_com_graphql_go_graphql.NewUnion(github_com_graphql_go_graphql.UnionConfig{
		Name:        "LineItemDish",
		Description: "The menu dish, can either be lunch or dessert",
		Types: []*github_com_graphql_go_graphql.Object{
			GraphQLLunchType,
			dessert.GraphQLDessertType,
		},
		ResolveType: func(p github_com_graphql_go_graphql.ResolveTypeParams) *github_com_graphql_go_graphql.Object {
			if _, ok := p.Value.(*LineItem_Lunch); ok {
				return GraphQLLunchType
			}
			if _, ok := p.Value.(*LineItem_TastyDessert); ok {
				return dessert.GraphQLDessertType
			}
			return nil
		},
	})
}
func (m *Menu) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Menu) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFlavortown(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LineItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LineItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PriceCents != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFlavortown(dAtA, i, uint64(m.PriceCents))
	}
	if m.CreatedAt != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFlavortown(dAtA, i, uint64(m.CreatedAt.Size()))
		n1, err := m.CreatedAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.UpdatedAt != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFlavortown(dAtA, i, uint64(m.UpdatedAt.Size()))
		n2, err := m.UpdatedAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Nothing != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintFlavortown(dAtA, i, uint64(m.Nothing.Size()))
		n3, err := m.Nothing.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Sides != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintFlavortown(dAtA, i, uint64(m.Sides.Size()))
		n4, err := m.Sides.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.QualityControl != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintFlavortown(dAtA, i, uint64(m.QualityControl))
	}
	if m.Dish != nil {
		nn5, err := m.Dish.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LineItem_Lunch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Lunch != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFlavortown(dAtA, i, uint64(m.Lunch.Size()))
		n6, err := m.Lunch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *LineItem_TastyDessert) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TastyDessert != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFlavortown(dAtA, i, uint64(m.TastyDessert.Size()))
		n7, err := m.TastyDessert.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *Lunch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Lunch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlavortown(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlavortown(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x1a
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovFlavortown(uint64(len(k))) + 1 + len(v) + sovFlavortown(uint64(len(v)))
			i = encodeVarintFlavortown(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintFlavortown(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintFlavortown(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Nothing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Nothing) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Void) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlavortown(dAtA, i, uint64(len(m.Void)))
		i += copy(dAtA[i:], m.Void)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintFlavortown(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedMenu(r randyFlavortown, easy bool) *Menu {
	this := &Menu{}
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Items = make([]*LineItem, v1)
		for i := 0; i < v1; i++ {
			this.Items[i] = NewPopulatedLineItem(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedFlavortown(r, 2)
	}
	return this
}

func NewPopulatedLineItem(r randyFlavortown, easy bool) *LineItem {
	this := &LineItem{}
	this.PriceCents = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		this.CreatedAt = types.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.UpdatedAt = types.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Nothing = NewPopulatedNothing(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Sides = types.NewPopulatedPermission(r, easy)
	}
	this.QualityControl = Quality([]int32{0, 1, 2}[r.Intn(3)])
	oneofNumber_Dish := []int32{100, 101}[r.Intn(2)]
	switch oneofNumber_Dish {
	case 100:
		this.Dish = NewPopulatedLineItem_Lunch(r, easy)
	case 101:
		this.Dish = NewPopulatedLineItem_TastyDessert(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedFlavortown(r, 102)
	}
	return this
}

func NewPopulatedLineItem_Lunch(r randyFlavortown, easy bool) *LineItem_Lunch {
	this := &LineItem_Lunch{}
	this.Lunch = NewPopulatedLunch(r, easy)
	return this
}
func NewPopulatedLineItem_TastyDessert(r randyFlavortown, easy bool) *LineItem_TastyDessert {
	this := &LineItem_TastyDessert{}
	this.TastyDessert = dessert.NewPopulatedDessert(r, easy)
	return this
}
func NewPopulatedLunch(r randyFlavortown, easy bool) *Lunch {
	this := &Lunch{}
	this.Name = string(randStringFlavortown(r))
	v2 := r.Intn(100)
	this.Description = make([]byte, v2)
	for i := 0; i < v2; i++ {
		this.Description[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(10)
		this.Tags = make(map[string]string)
		for i := 0; i < v3; i++ {
			this.Tags[randStringFlavortown(r)] = randStringFlavortown(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedFlavortown(r, 4)
	}
	return this
}

func NewPopulatedNothing(r randyFlavortown, easy bool) *Nothing {
	this := &Nothing{}
	this.Void = string(randStringFlavortown(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedFlavortown(r, 2)
	}
	return this
}

type randyFlavortown interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneFlavortown(r randyFlavortown) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringFlavortown(r randyFlavortown) string {
	v4 := r.Intn(100)
	tmps := make([]rune, v4)
	for i := 0; i < v4; i++ {
		tmps[i] = randUTF8RuneFlavortown(r)
	}
	return string(tmps)
}
func randUnrecognizedFlavortown(r randyFlavortown, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldFlavortown(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldFlavortown(dAtA []byte, r randyFlavortown, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateFlavortown(dAtA, uint64(key))
		v5 := r.Int63()
		if r.Intn(2) == 0 {
			v5 *= -1
		}
		dAtA = encodeVarintPopulateFlavortown(dAtA, uint64(v5))
	case 1:
		dAtA = encodeVarintPopulateFlavortown(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateFlavortown(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateFlavortown(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateFlavortown(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateFlavortown(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Menu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovFlavortown(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LineItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PriceCents != 0 {
		n += 1 + sovFlavortown(uint64(m.PriceCents))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovFlavortown(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovFlavortown(uint64(l))
	}
	if m.Nothing != nil {
		l = m.Nothing.Size()
		n += 1 + l + sovFlavortown(uint64(l))
	}
	if m.Sides != nil {
		l = m.Sides.Size()
		n += 1 + l + sovFlavortown(uint64(l))
	}
	if m.QualityControl != 0 {
		n += 1 + sovFlavortown(uint64(m.QualityControl))
	}
	if m.Dish != nil {
		n += m.Dish.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LineItem_Lunch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lunch != nil {
		l = m.Lunch.Size()
		n += 2 + l + sovFlavortown(uint64(l))
	}
	return n
}
func (m *LineItem_TastyDessert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TastyDessert != nil {
		l = m.TastyDessert.Size()
		n += 2 + l + sovFlavortown(uint64(l))
	}
	return n
}
func (m *Lunch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlavortown(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFlavortown(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlavortown(uint64(len(k))) + 1 + len(v) + sovFlavortown(uint64(len(v)))
			n += mapEntrySize + 1 + sovFlavortown(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Nothing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Void)
	if l > 0 {
		n += 1 + l + sovFlavortown(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFlavortown(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFlavortown(x uint64) (n int) {
	return sovFlavortown(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Menu) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlavortown
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Menu: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Menu: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlavortown
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &LineItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlavortown(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlavortown
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlavortown
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LineItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlavortown
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LineItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LineItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceCents", wireType)
			}
			m.PriceCents = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceCents |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlavortown
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlavortown
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &types.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nothing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlavortown
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nothing == nil {
				m.Nothing = &Nothing{}
			}
			if err := m.Nothing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sides", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlavortown
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sides == nil {
				m.Sides = &types.Permission{}
			}
			if err := m.Sides.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QualityControl", wireType)
			}
			m.QualityControl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QualityControl |= Quality(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lunch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlavortown
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Lunch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Dish = &LineItem_Lunch{v}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TastyDessert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlavortown
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &dessert.Dessert{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Dish = &LineItem_TastyDessert{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlavortown(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlavortown
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlavortown
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Lunch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlavortown
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lunch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lunch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlavortown
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlavortown
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = append(m.Description[:0], dAtA[iNdEx:postIndex]...)
			if m.Description == nil {
				m.Description = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlavortown
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlavortown
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlavortown
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlavortown
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlavortown
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlavortown
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthFlavortown
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthFlavortown
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlavortown(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFlavortown
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlavortown(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlavortown
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlavortown
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Nothing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlavortown
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nothing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nothing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Void", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlavortown
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Void = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlavortown(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlavortown
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlavortown
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlavortown(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlavortown
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFlavortown
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthFlavortown
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFlavortown
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFlavortown(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthFlavortown
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFlavortown = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlavortown   = fmt.Errorf("proto: integer overflow")
)
